%% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,english]{sphinxmanual}
\ifdefined\pdfpxdimen
   \let\sphinxpxdimen\pdfpxdimen\else\newdimen\sphinxpxdimen
\fi \sphinxpxdimen=.75bp\relax

\PassOptionsToPackage{warn}{textcomp}
\usepackage[utf8]{inputenc}
\ifdefined\DeclareUnicodeCharacter
 \ifdefined\DeclareUnicodeCharacterAsOptional
  \DeclareUnicodeCharacter{"00A0}{\nobreakspace}
  \DeclareUnicodeCharacter{"2500}{\sphinxunichar{2500}}
  \DeclareUnicodeCharacter{"2502}{\sphinxunichar{2502}}
  \DeclareUnicodeCharacter{"2514}{\sphinxunichar{2514}}
  \DeclareUnicodeCharacter{"251C}{\sphinxunichar{251C}}
  \DeclareUnicodeCharacter{"2572}{\textbackslash}
 \else
  \DeclareUnicodeCharacter{00A0}{\nobreakspace}
  \DeclareUnicodeCharacter{2500}{\sphinxunichar{2500}}
  \DeclareUnicodeCharacter{2502}{\sphinxunichar{2502}}
  \DeclareUnicodeCharacter{2514}{\sphinxunichar{2514}}
  \DeclareUnicodeCharacter{251C}{\sphinxunichar{251C}}
  \DeclareUnicodeCharacter{2572}{\textbackslash}
 \fi
\fi
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amssymb,amstext}
\usepackage{babel}
\usepackage{times}
\usepackage[Bjarne]{fncychap}
\usepackage{sphinx}

\usepackage{geometry}

% Include hyperref last.
\usepackage{hyperref}
% Fix anchor placement for figures with captions.
\usepackage{hypcap}% it must be loaded after hyperref.
% Set up styles of URL: it should be placed after hyperref.
\urlstyle{same}
\addto\captionsenglish{\renewcommand{\contentsname}{Contents:}}

\addto\captionsenglish{\renewcommand{\figurename}{Fig.}}
\addto\captionsenglish{\renewcommand{\tablename}{Table}}
\addto\captionsenglish{\renewcommand{\literalblockname}{Listing}}

\addto\captionsenglish{\renewcommand{\literalblockcontinuedname}{continued from previous page}}
\addto\captionsenglish{\renewcommand{\literalblockcontinuesname}{continues on next page}}

\addto\extrasenglish{\def\pageautorefname{page}}

\setcounter{tocdepth}{1}



\title{NNS Documentation}
\date{May 24, 2018}
\release{}
\author{Yongxin Liu; Jianying Li}
\newcommand{\sphinxlogo}{\vbox{}}
\renewcommand{\releasename}{}
\makeindex

\begin{document}

\maketitle
\sphinxtableofcontents
\phantomsection\label{\detokenize{index::doc}}



\chapter{NNS Background}
\label{\detokenize{nns_background:welcome-to-nns-s-documentation}}\label{\detokenize{nns_background::doc}}\label{\detokenize{nns_background:nns-background}}
\noindent{\hspace*{\fill}\scalebox{0.500000}{\sphinxincludegraphics[width=370\sphinxpxdimen,height=351\sphinxpxdimen]{{logo}.png}}}

NNS is the NEO Name Service, a distributed, open, and extensible naming system based on the NEO blockchain.

Our primary goal is to replace irregular string such as wallet address and smart contract Hash which are hard to memorize for humans with words and phrases.
We will offer ending in “.neo” name service first.

Through name service, people don’t need to remember address and Hash they don’t understand anymore.
You could make a transfer or use contracts by just knowing a word or phrase.

NNS can be used to resolve a wide variety of resources.
The initial standard for NNS defines resolution for NEO addresses or Smart contracts(ScriptHash), but the system is extensible,
allowing more resource types to be resolved in future without NNS upgrades.


\section{Why do We Need NNS?}
\label{\detokenize{nns_background:why-do-we-need-nns}}
When Satoshi Nakamoto designed Bitcoin address, he created base58 encode by himself rather than adopting base 64 encode commonly used in coding community.
In the base58 encode, he deleted some ambiguous characters: 0(zero), O(capital letter o), I(capital letter i) and l( lower case letter L).

This reflects Satoshi Nakamoto’s consideration for the usability of blockchain address. However, blockchain address is still not human-friendly enough,
because it’s too long, hard to memorize and not easy to compare whether it’s right or wrong.
As blockchain’s popularity increases, the shortcomings of its address will be more obvious.

As we won’t use a 32-byte string as an E-mail account today, alias service could provide a huge help for the usability of blockchain system.
As IPFS has its alias service IPNS, and Ethereum ENS, We argue that NEO system should have its own alias service.
We call it as NEO Name Service(NNS), NEL community will increase the usability of NEO blockchain by providing NNS service.

The primary usage scenario of alias service is transfer of tokens via alias, especially for those accounts who need to make public their wallet addresses and do not need to change their addresses frequently.
For example, when an ICO is underway, the project initiator need to make public its official wallet address on its official website.

But even the official wallet address is modified by hackers, it is difficult for investors to notice that.
So if the project initiator could make public a short and easy-to-remember address alias, then even it’s modified, it could be easily found,
thus preventing wallet address from being modified by hackers.
What types of resource an alias points to is extensible, as long as corresponding resolver is achieved.

Besides pointing to an account address, an alias could also point to a contract address, so smart contracts can be invoked via alias.
There will probably be many smart contract templates, thus mistakes could be avoided if  the alias service is used to invoke smart contract templates.

As blockchain is the infrastructure of next generation Internet, an increasing number of services will be based on blockchain.
For example, the decentralized cloud storage service. File addressing is done through the file’s hash value-the only identifier.

We could give a hash value an alias such as a file name that could be understood easily, then we map the alias to the file’s hash value to achieve the file addressing.
So alias service could be used together with NEOFS-the decentralized file storage based on NEO in future. NNS could also provide alias service for decentralized messaging,
decentralized email service and so forth as more and more services are being built on NEO.


\section{Relationship Between NNS and ENS}
\label{\detokenize{nns_background:relationship-between-nns-and-ens}}
NNS and ENS share the same goal of increasing the usability of blockchain.
But they are based on different blockchain platforms and serve different blockchain platforms.

We would like to extend our thanks to ENS, because we drew on experience from ENS when we designed NNS system,
meanwhile we also made lots of innovative designs. For example, we split the owner contract from registry module to achieve more flexible ownership control.

We have two types of resolutions: quick resolution and complete resolution.
We have introduced a smart token in our economic model to achieve redistribution of system costs.


\chapter{NNS System Design Overview}
\label{\detokenize{nns_system:nns-system-design-overview}}\label{\detokenize{nns_system::doc}}

\section{NNS System Functions}
\label{\detokenize{nns_system:nns-system-functions}}
NNS system has two functions: first, to resolve a human-readable name like beautiful.neo
into machine-readable identifiers like NEO’s address; second, to provide descriptive data for domain names,
such as whois, contract interface description and so forth.

NNS has similar goals to DNS. But based on blockchain architecture design,
NNS is decentralized and serves blockchain network. NNS operates on a system of dot-separated hierarchical names called domains,
with the owner of a domain having full control over the distribution of subdomains.

Top-level domains, like ‘.neo’ and ‘.gas’, are owned by smart contracts called registrars.
One registrar manages one root domain name and specifies rules governing the allocation of their subdomains.
Anyone may, by following the rules imposed by these registrar contracts, obtain ownership of a second-level domain for their own use.


\section{NNS Architecture}
\label{\detokenize{nns_system:nns-architecture}}
NNS has four components:
1. Top-level domain name contract.( domain name root is the script that manages root domain name. )
\begin{enumerate}
\setcounter{enumi}{1}
\item {} 
The owner (the owner could be a personal account’s address or a smart contract)

\item {} 
Registrar (A registrar is simply a smart contract that issues subdomains of that domain to users. The root domain name specifies a root domain name’s registry.)

\item {} 
Resolver (responsible for resolving a domain name or its subdomain names. )

\end{enumerate}


\subsection{Top-level Domain Name Contract}
\label{\detokenize{nns_system:top-level-domain-name-contract}}
Domain name root is the manager of all the information of a root domain name such as .test.
No matter it is a second-level domain name like aa.test or third-level domain name like bbb.aa.test,
both of their owners are kept in the domain name root which keeps the following data in the form of a dictionary.
\begin{enumerate}
\item {} 
The owner of the domain name

\item {} 
The registrar of the domain name

\item {} 
The resolver of the domain name

\item {} 
The TTL(time to live) of the domain name

\end{enumerate}


\subsection{Owner}
\label{\detokenize{nns_system:owner}}
The owner of the domain name could be either an account address or a smart contract.
(ENS’s design is a smart contract that owns a domain name is called registrar. Actually, registrar is the owner’s exception.
We separate the owner of the domain name from the registrar, making the system clearer.)
Owners of domain names may:
\begin{enumerate}
\item {} 
Transfer the ownership of the domain name to another address.

\item {} 
Change registrar. The most common domain registrar is “administrators allocate subdomains manually.”

\item {} 
Change the resolver.

\end{enumerate}

A smart contract is allowed to be the owner, which provides a variety of ownership models.
\begin{enumerate}
\item {} 
The domain name co-owned by two persons. The transfer of domain names or changing registrars is only possible with two people’s signatures.

\item {} 
The domain co-owned by multi-person. The transfer of domain names or changing registrars is only possible with more than 50\% of people’s signatures.

\end{enumerate}

If the owner of the domain name is an account address, the user could invoke registrar’s interface to manage second-level domain names.


\subsection{Registrar}
\label{\detokenize{nns_system:registrar}}
(ENS’s design is a smart contract which owns top-level domains is called registrar. Actually, the registrar is the owner’s special case.
Our separation of the owner of the domain name from the registrar makes the system clearer. Most users don’t sell their second-level domain names,
so most users just need to configure a resolver rather than a registrar.)

A registrar is responsible for specifying subdomain names of a domain name to other owners.
The registrar operates by invoking the domain root’s script. The domain name root checks whether the registrar has the authority to operate this domain name.
The registrar has two functions:
\begin{enumerate}
\item {} 
To re-specify subdomain names of a domain name to other owners.

\item {} 
To check whether the owner of a subdomain name is legal or not because second-level domain names could be transferred to others after third-level domain names are sold.

\end{enumerate}

In the complete resolution, the registrar will be asked whether its subdomain names are allocated to specified owners. If not, the resolution is invalid.
A registrar is a smart contract. There could be many types of registrars.
\begin{enumerate}
\item {} 
“First come, first served” registrar. Users are free to grab domain names. Our testnet’s .test domain names will be registered in a “first come, first served” way.

\item {} 
Administers allocate registrars manually. An administrator sets up how the ownership of subdomain names is processed. Individuals with second-level domains allocate subdomain names manually.

\item {} 
Registrar auction. Testnet’s .neo domains and mainnet’s .neo domain names will be registered in the way of auction with collaterals.

\end{enumerate}


\subsection{Resolver}
\label{\detokenize{nns_system:resolver}}
NNS’s main function is to finish the mapping from the domain name to the resolver. The resolver is a smart contract which interprets names into addresses.

Any smart contracts which follow NNS resolver rules could be configured to resolvers. NNS will provide general-purpose resolvers.
If new protocol types need to be added, the direct configuration can be done without changing NNS system if current NNS rules are not disrupted.


\subsection{Resolution Rules}
\label{\detokenize{nns_system:resolution-rules}}

\subsubsection{Domain Name Storage}
\label{\detokenize{nns_system:domain-name-storage}}
The domain name NNS stores are 32-byte hashes, rather than the plain text of the domain name. Here are reasons for this design.
\begin{enumerate}
\item {} 
A unified process allows any length of the domain name.

\item {} 
It preserves the privacy of the domain name to some extent.

\item {} 
The algorithm for converting a domain name to a hash is called NameHash, and we’ll explain it in other documentation.

\end{enumerate}

The definition of NameHash is recursive.
\begin{enumerate}
\item {} 
for example aaa.neo corresponding

\end{enumerate}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
hashA  =  hash256(hash256(“.neo”) + “aaa”)
\end{sphinxVerbatim}
\begin{enumerate}
\setcounter{enumi}{1}
\item {} 
then bbb.aaa.neo corresponding

\end{enumerate}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
hashB  =  hash256(hashA+”bbb”)
\end{sphinxVerbatim}
\begin{enumerate}
\setcounter{enumi}{2}
\item {} 
then  ccc.bbb.aaa.neo corresponding

\end{enumerate}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
HashC  =  hash256(hashB+”ccc”)
\end{sphinxVerbatim}

This definition allows us to store all levels of domain names, level 1, level 2, to countless levels, in a data structure: Map \textless{}hash256, parser\textgreater{} in a flat way.
This is exactly how the registrar saves the resolution of domain names.

This recursive calculation of NameHash can be expressed as a function:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Hash} \PYG{o}{=} \PYG{n}{NameHash} \PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{xxx.xxx.xxx ...}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

for the realization of NameHash, please refer to {\hyperref[\detokenize{nns_protocol:namehash}]{\sphinxcrossref{\DUrole{std,std-ref}{Detailed Explanation NameHash Algorithm}}}}.


\subsubsection{Resolution Process}
\label{\detokenize{nns_system:resolution-process}}
The user invokes the resolution function of the root domain name for resolution, and the root domain name provides both complete and quick resolution.
You can invoke it as need. You can also query the resolver and invoke it by yourself.

\sphinxstylestrong{Quick resolution}

Quick resolution root domain name directly searches the resolver of a complete domain name. if not, search the parent domain name’s resolver and then invokes the resolver for resolution.
There are fewer operations for a quick resolution, but there’s a flaw: the third-level domain name is sold to someone else and the resolver exists, but the second-level domain name has been transferred. At this point, the domain name can still be resolved.

\sphinxstylestrong{Complete resolution}

In a complete manner, the root of the domain name will start with the root domain name and queries ownership and TTL layer by layer. It will fail if they don’t comply with.

More operations are needed in the complete resolution and operations has a linear growth with the layer number of domain names.


\section{NNS economic model}
\label{\detokenize{nns_system:nns-economic-model}}
Two kinds of tokens were introduced in the economic model of NNS. One is NNC, which is a UTXO asset and has a total supply of 1 billion. The other is SGS, which is
a NEP5 token. It’s bound with NEO’s GAS at the ratio of 1:1 and they can be converted with other.


\subsection{NNC: an equity proof token}
\label{\detokenize{nns_system:nnc-an-equity-proof-token}}
NNC is an equity proof token introduced into the NNS system. In order to sustain the system, NNS has introduced a fee redistribution system. The fees charged for all domain name auctions will be completely redistributed to NNC’s holders.

The initial issuance of the NNC is in the form of airdrop(s). NNC will be only airdropped to NEO holders. Specific airdrop rules will be announced in the future.


\subsection{SGAS-a kind of gas token}
\label{\detokenize{nns_system:sgas-a-kind-of-gas-token}}
In order to facilitate the use of GAS in application contracts, NNS has issued a NEP5-based token with a total supply of 100 million, which is  bound with NEO’s GAS at the ratio of 1:1 and they can be converted with each other freely..

The GAS used for the redemption of SGAS will be stored in the account of the SGAS contract. NNS will not transfer or use this GAS. Therefore, it is guaranteed that as long as the user holds the SGAS, it can be converted to the same amount of GAS.

In the NNS system, SGAS mainly has the following functions:

It can be converted with GAS and vice-versa
- Recharge/withdraw from the registrar.
- Participate in domain auctions.
- Auction fee payment

In addition to being used within the NNS system, since the SGAS itself is a NEP5 token system that is deployed on the Mainnet, all contract applications can also use this SGAS contract to perform convenient intra-contract GAS operations.


\subsection{Bonus pools}
\label{\detokenize{nns_system:bonus-pools}}
When a user bids for a domain name, NNS will generate income from SGAS. There are two main sources:
\begin{enumerate}
\item {} 
The bid winner. If the user wins the bid and obtains the domain name ownership, then the bid winner will be charged all the bid fund as the fee.

\item {} 
The bid loser. For users who participate in the auction, but lose the bid, 10\% of the bid is charged as a fee.

\end{enumerate}

All fee income will be transferred to bonus pools. In the bonus pools, all NNC holders can receive SGAS in proportion to their NNC holdings.


\section{Domain Name Browser}
\label{\detokenize{nns_system:domain-name-browser}}
NNS domain name browser is the entrance which provides NNS domain name query, auction, transfer and other functions.


\section{Reverse Resolution}
\label{\detokenize{nns_system:reverse-resolution}}
NNS will support reverse resolution which will become an effective way to verify addresses and smart contracts.


\section{Roadmap}
\label{\detokenize{nns_system:roadmap}}
\sphinxstylestrong{First quarter, 2018}
\begin{itemize}
\item {} 
January 2018, officially released NNS technical white paper

\item {} 
January 2018, completed the technical principle test and verification

\item {} 
January 31st, 2018, release the NNS Phase 1 testing service, including registrar and resolver, on the test net, anyone can register unregistered and rules-compliant domain names.

\item {} 
February 2018,  launch testnet-based Domain Name Browser V1

\end{itemize}

\sphinxstylestrong{Second quarter, 2018}
\begin{itemize}
\item {} 
March 2018, issue NNC on testnet.

\item {} 
March 2018, release NNS Stage 2 testing service including bidding service on testnet when anyone can apply to NEL for NDS bidding test domain name

\item {} 
April 2018, launch testnet-based domain name browser V2.

\item {} 
May 2018, issue NNC on mainnet.

\item {} 
June 2018, release NNS service on mainnet. Here comes Neo domain name era.

\item {} 
June 2018, release mainnet-based domain name browser.

\end{itemize}


\chapter{Design Details}
\label{\detokenize{nns_protocol:design-details}}\label{\detokenize{nns_protocol::doc}}

\section{NNS Protocol Specifications}
\label{\detokenize{nns_protocol:nns-protocol-specifications}}
The URL we usually use on the Internet is as follows,

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{http}\PYG{p}{:}\PYG{o}{/}\PYG{o}{/}\PYG{n}{aaa}\PYG{o}{.}\PYG{n}{bbb}\PYG{o}{.}\PYG{n}{test}\PYG{o}{/}\PYG{n}{xxx}
\end{sphinxVerbatim}
\begin{enumerate}
\item {} 
HTTP is a protocol, the domain name and protocol will be passed on separately when NNS service is requested.

\item {} 
aaa.bbb.test is the domain name, NNS service request using the hash of the domain name

\item {} 
Xxx is the path, the path is not processed at the DNS level, the same goes with nns, if there is a path, it will be processed in other ways.

\end{enumerate}

Definitions of using strings in NNS protocol
The following are tentative definitions.

\sphinxstylestrong{HTTP}
\begin{quote}

\sphinxtitleref{HTTP protocol points to a string, which means it’s an Internet address.}
\end{quote}

\sphinxstylestrong{addr}
\begin{quote}

\sphinxtitleref{addr protocol points to a string, which means it’s an NEO address. Like: AdzQq1DmnHq86yyDUkU3jKdHwLUe2MLAVv}
\end{quote}

\sphinxstylestrong{script}
\begin{quote}

\sphinxtitleref{script protocol points to a byte{[}{]}, which means a NEO ScriptHash. Like: 0xf3b1c99910babe5c23d0b4fd0104ee84ffeec2a5}
\end{quote}

One and the same domain name is processed differently by different protocols.
\begin{itemize}
\item {} 
\sphinxurl{http://abc.test}  may point to \sphinxurl{http://www.163.com}

\item {} 
addr://abc.test  may point to AdzQq1DmnHq86yyDUkU3jKdHwLUe2MLAVv

\item {} 
script://abc.test  may point to 0xf3b1c99910babe5c23d0b4fd0104ee84ffeec2a5

\end{itemize}


\section{Detailed Explanation NameHash Algorithm}
\label{\detokenize{nns_protocol:namehash}}\label{\detokenize{nns_protocol:detailed-explanation-namehash-algorithm}}

\subsection{Namehash}
\label{\detokenize{nns_protocol:id1}}
The domain name NNS stores are 32byte hashes, rather than the plain text of the original domain name. Here are reasons for this design.
\begin{enumerate}
\item {} 
A unified process allows any length of the domain name.

\item {} 
It preserves the privacy of the domain name to some extent.

\item {} 
The algorithm for converting a domain name to a hash is called NameHash,

\end{enumerate}


\subsection{Domain, Domainarray, and Protocol}
\label{\detokenize{nns_protocol:domain-domainarray-and-protocol}}
The URL we usually use on the Internet is as follows,

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{http}\PYG{p}{:}\PYG{o}{/}\PYG{o}{/}\PYG{n}{aaa}\PYG{o}{.}\PYG{n}{bbb}\PYG{o}{.}\PYG{n}{test}\PYG{o}{/}\PYG{n}{xxx}
\end{sphinxVerbatim}
\begin{enumerate}
\item {} 
HTTP is a protocol, the domain name and protocol will be passed on separately when NNS service is requested.

\item {} 
aaa.bbb.test is the domain name, NNS service request using the hash of the domain name

\item {} 
Xxx is the path, the path is not processed at the DNS level, the same goes with nns, if there is a path, it will be processed in other ways.

\end{enumerate}

NNS uses domain name’s array rather domain name, which is a more direct process.
Domain name aaa.bb.test is converted into byte array as {[}“test”,”bb”,”aa”{]}
You could invoke the resolution this way

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{NNS}\PYG{o}{.}\PYG{n}{ResolveFull}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{http}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{test}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{bb}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{aa}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

And let the contract to calculate namehash.


\subsection{NameHash Algorithm}
\label{\detokenize{nns_protocol:namehash-algorithm}}
NameHash algorithm is a way to calculate hash step by step after converting domain name into DomainArray. Its code is as follows:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{/}\PYG{o}{/} \PYG{n}{algorithm} \PYG{k}{for} \PYG{n}{converting} \PYG{n}{domain} \PYG{n}{names} \PYG{n}{into} \PYG{n}{a} \PYG{n+nb}{hash}
\PYG{n}{static} \PYG{n}{byte}\PYG{p}{[}\PYG{p}{]} \PYG{n}{nameHash}\PYG{p}{(}\PYG{n}{string} \PYG{n}{domain}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{k}{return} \PYG{n}{SmartContract}\PYG{o}{.}\PYG{n}{Sha256}\PYG{p}{(}\PYG{n}{domain}\PYG{o}{.}\PYG{n}{AsByteArray}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{n}{static} \PYG{n}{byte}\PYG{p}{[}\PYG{p}{]} \PYG{n}{nameHashSub}\PYG{p}{(}\PYG{n}{byte}\PYG{p}{[}\PYG{p}{]} \PYG{n}{roothash}\PYG{p}{,} \PYG{n}{string} \PYG{n}{subdomain}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{n}{var} \PYG{n}{domain} \PYG{o}{=} \PYG{n}{SmartContract}\PYG{o}{.}\PYG{n}{Sha256}\PYG{p}{(}\PYG{n}{subdomain}\PYG{o}{.}\PYG{n}{AsByteArray}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{o}{.}\PYG{n}{Concat}\PYG{p}{(}\PYG{n}{roothash}\PYG{p}{)}\PYG{p}{;}
    \PYG{k}{return} \PYG{n}{SmartContract}\PYG{o}{.}\PYG{n}{Sha256}\PYG{p}{(}\PYG{n}{domain}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{n}{static} \PYG{n}{byte}\PYG{p}{[}\PYG{p}{]} \PYG{n}{nameHashArray}\PYG{p}{(}\PYG{n}{string}\PYG{p}{[}\PYG{p}{]} \PYG{n}{domainarray}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{n}{byte}\PYG{p}{[}\PYG{p}{]} \PYG{n+nb}{hash} \PYG{o}{=} \PYG{n}{nameHash}\PYG{p}{(}\PYG{n}{domainarray}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
    \PYG{k}{for} \PYG{p}{(}\PYG{n}{var} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{domainarray}\PYG{o}{.}\PYG{n}{Length}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n+nb}{hash} \PYG{o}{=} \PYG{n}{nameHashSub}\PYG{p}{(}\PYG{n+nb}{hash}\PYG{p}{,} \PYG{n}{domainarray}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{return} \PYG{n+nb}{hash}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}


\subsection{Quick Resolution}
\label{\detokenize{nns_protocol:quick-resolution}}
Complete resolution introduces the whole DomainArray and let smart contracts to check every layer’s resolution one by one. Calculating NameHash could also be done on Client, and then is passed into smart contracts. It’s invoked this way:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{/}\PYG{o}{/} \PYG{n}{query} \PYG{n}{http}\PYG{p}{:}\PYG{o}{/}\PYG{o}{/}\PYG{n}{aaa}\PYG{o}{.}\PYG{n}{bbb}\PYG{o}{.}\PYG{n}{test}
\PYG{n}{var} \PYG{n+nb}{hash} \PYG{o}{=} \PYG{n}{nameHashArray}\PYG{p}{(}\PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{test}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{bbb}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}\PYG{o}{/}\PYG{o}{/} \PYG{n}{can} \PYG{n}{be} \PYG{n}{calculated} \PYG{n}{by} \PYG{n}{Client}
\PYG{n}{NNS}\PYG{o}{.}\PYG{n}{Resolve}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{http}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{n+nb}{hash}\PYG{p}{,}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{aaa}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}\PYG{o}{/}\PYG{o}{/} \PYG{n}{invoke} \PYG{n}{smart} \PYG{n}{contracts}
\end{sphinxVerbatim}

or

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{/}\PYG{o}{/}\PYG{n}{query} \PYG{n}{http}\PYG{p}{:}\PYG{o}{/}\PYG{o}{/}\PYG{n}{bbb}\PYG{o}{.}\PYG{n}{test}
\PYG{n}{var} \PYG{n+nb}{hash} \PYG{o}{=} \PYG{n}{nameHashArray}\PYG{p}{(}\PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{test}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{bbb}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}\PYG{o}{/}\PYG{o}{/} \PYG{n}{can} \PYG{n}{be} \PYG{n}{calculated} \PYG{n}{by} \PYG{n}{Client}
\PYG{n}{NNS}\PYG{o}{.}\PYG{n}{Resolve}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{http}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{n+nb}{hash}\PYG{p}{,}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}\PYG{o}{/}\PYG{o}{/} \PYG{n}{invoke} \PYG{n}{smart} \PYG{n}{contracts}
\end{sphinxVerbatim}

You may be thinking why querying aaa.bbb.test is not like this.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{/}\PYG{o}{/} \PYG{n}{query} \PYG{n}{http}\PYG{p}{:}\PYG{o}{/}\PYG{o}{/}\PYG{n}{aaa}\PYG{o}{.}\PYG{n}{bbb}\PYG{o}{.}\PYG{n}{test}
\PYG{n}{var} \PYG{n+nb}{hash} \PYG{o}{=} \PYG{n}{nameHashArray}\PYG{p}{(}\PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{test}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{bbb}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{aaa}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}\PYG{o}{/}\PYG{o}{/} \PYG{n}{can} \PYG{n}{be} \PYG{n}{calculated} \PYG{n}{by} \PYG{n}{Client}
\PYG{n}{NNS}\PYG{o}{.}\PYG{n}{Resolve}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{http}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{n+nb}{hash}\PYG{p}{,}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}\PYG{o}{/}\PYG{o}{/} \PYG{n}{invoke} \PYG{n}{smart} \PYG{n}{contract}
\end{sphinxVerbatim}

We have to consider whether aaa.bb.test has a separate resolver. If aaa.bb.test is sold to someone else,
it specifies an independent resolver so that it can be queried. If aaa.bb.test does not have a separate resolver, it is resolved by bb.test’s resolver.
So this cannot be queried.

The first query, regardless of whether aaa.bb.test has an independent resolver, can be found.


\section{Detailed Explanation of Top-level Domain Name}
\label{\detokenize{nns_protocol:detailed-explanation-of-top-level-domain-name}}

\subsection{Function Signature of Top-level Domain Name Contracts}
\label{\detokenize{nns_protocol:function-signature-of-top-level-domain-name-contracts}}
The function signature is as follows:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{public} \PYG{n}{static} \PYG{n+nb}{object} \PYG{n}{Main}\PYG{p}{(}\PYG{n}{string} \PYG{n}{method}\PYG{p}{,} \PYG{n+nb}{object}\PYG{p}{[}\PYG{p}{]} \PYG{n}{args}\PYG{p}{)}
\end{sphinxVerbatim}

Deploying adopts a configuration of parameter 0710, return value 05


\subsection{Interface of Top-level Domain Name Contract}
\label{\detokenize{nns_protocol:interface-of-top-level-domain-name-contract}}
Top-level domain name’s interface is composed of three parts
Universal interface. It does not require permission verification and can be invoked by everyone.
Owner interface. It is valid only when it’s invoked by the owner signature or the owner script.
Registrar interface. It’s valid only when it’s invoked by the registrar script.


\subsection{Universal Interface}
\label{\detokenize{nns_protocol:universal-interface}}
The universal interface doesn’t need permission verification. Its code is as follows.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{if} \PYG{p}{(}\PYG{n}{method} \PYG{o}{==} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{rootName}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
    \PYG{k}{return} \PYG{n}{rootName}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{k}{if} \PYG{p}{(}\PYG{n}{method} \PYG{o}{==} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{rootNameHash}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
    \PYG{k}{return} \PYG{n}{rootNameHash}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{k}{if} \PYG{p}{(}\PYG{n}{method} \PYG{o}{==} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{getInfo}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
    \PYG{k}{return} \PYG{n}{getInfo}\PYG{p}{(}\PYG{p}{(}\PYG{n}{byte}\PYG{p}{[}\PYG{p}{]}\PYG{p}{)}\PYG{n}{args}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
\PYG{k}{if} \PYG{p}{(}\PYG{n}{method} \PYG{o}{==} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{nameHash}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
    \PYG{k}{return} \PYG{n}{nameHash}\PYG{p}{(}\PYG{p}{(}\PYG{n}{string}\PYG{p}{)}\PYG{n}{args}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
\PYG{k}{if} \PYG{p}{(}\PYG{n}{method} \PYG{o}{==} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{nameHashSub}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
    \PYG{k}{return} \PYG{n}{nameHashSub}\PYG{p}{(}\PYG{p}{(}\PYG{n}{byte}\PYG{p}{[}\PYG{p}{]}\PYG{p}{)}\PYG{n}{args}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{p}{(}\PYG{n}{string}\PYG{p}{)}\PYG{n}{args}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
\PYG{k}{if} \PYG{p}{(}\PYG{n}{method} \PYG{o}{==} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{nameHashArray}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
    \PYG{k}{return} \PYG{n}{nameHashArray}\PYG{p}{(}\PYG{p}{(}\PYG{n}{string}\PYG{p}{[}\PYG{p}{]}\PYG{p}{)}\PYG{n}{args}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
\PYG{k}{if} \PYG{p}{(}\PYG{n}{method} \PYG{o}{==} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{resolve}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
    \PYG{k}{return} \PYG{n}{resolve}\PYG{p}{(}\PYG{p}{(}\PYG{n}{string}\PYG{p}{)}\PYG{n}{args}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{p}{(}\PYG{n}{byte}\PYG{p}{[}\PYG{p}{]}\PYG{p}{)}\PYG{n}{args}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{p}{(}\PYG{n}{string}\PYG{p}{)}\PYG{n}{args}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
\PYG{k}{if} \PYG{p}{(}\PYG{n}{method} \PYG{o}{==} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{resolveFull}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
    \PYG{k}{return} \PYG{n}{resolveFull}\PYG{p}{(}\PYG{p}{(}\PYG{n}{string}\PYG{p}{)}\PYG{n}{args}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{p}{(}\PYG{n}{string}\PYG{p}{[}\PYG{p}{]}\PYG{p}{)}\PYG{n}{args}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\subsubsection{rootName()}
\label{\detokenize{nns_protocol:rootname}}
Return the root domain name that the current top-level domain name corresponds to, its return value is a string.


\subsubsection{rootNameHash()}
\label{\detokenize{nns_protocol:rootnamehash}}
Return NameHash the current top-level domain name corresponds to, its return values are byte{[}{]}


\subsubsection{getInfo(byte{[}{]} namehash)}
\label{\detokenize{nns_protocol:getinfo-byte-namehash}}
Return a domain name’s information, its return value is an array as follows

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{[}
    \PYG{n}{byte}\PYG{p}{[}\PYG{p}{]} \PYG{n}{owner}\PYG{o}{/}\PYG{o}{/}\PYG{n}{owner}
    \PYG{n}{byte}\PYG{p}{[}\PYG{p}{]} \PYG{n}{register}\PYG{o}{/}\PYG{o}{/}\PYG{n}{registrar}
    \PYG{n}{byte}\PYG{p}{[}\PYG{p}{]} \PYG{n}{resolver}\PYG{o}{/}\PYG{o}{/}\PYG{n}{resolver}
    \PYG{n}{BigInteger} \PYG{n}{ttl}\PYG{o}{/}\PYG{o}{/}\PYG{n}{TTL}
\PYG{p}{]}
\end{sphinxVerbatim}


\subsubsection{nameHash(string domain)}
\label{\detokenize{nns_protocol:namehash-string-domain}}
Convert a section of the domain name into NameHash. For example:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{nameHash}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{test}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{nameHash}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{abc}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\end{sphinxVerbatim}

Its return value is byte{[}{]}


\subsubsection{nameHashSub(byte{[}{]} domainhash,string subdomain)}
\label{\detokenize{nns_protocol:namehashsub-byte-domainhash-string-subdomain}}
Calculate subdomain name’s NameHash. For example:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
var hash = nameHash(\PYGZdq{}test\PYGZdq{});
var hashsub = nameHashSub(hash,\PYGZdq{}abc\PYGZdq{})// calculate abc.test’s namehash
\end{sphinxVerbatim}

it’s return value is byte{[}{]}


\subsubsection{nameHashArray(string{[}{]} nameArray)}
\label{\detokenize{nns_protocol:namehasharray-string-namearray}}
Calculate NameArray’s NameHash，aa.bb.cc.test corresponding nameArray is {[}“test”,”cc”,”bb”,”aa”{]}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{var} \PYG{n+nb}{hash} \PYG{o}{=} \PYG{n}{nameHashArray}\PYG{p}{(}\PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{test}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{cc}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{bb}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{aa}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\subsubsection{resolve(string protocol,byte{[}{]} hash,string or int(0) subdomain)}
\label{\detokenize{nns_protocol:resolve-string-protocol-byte-hash-string-or-int-0-subdomain}}
resolve a domain name

The first parameter is a protocol

For example, HTTP maps a domain name to an Internet address.

For example, addr maps a domain name to an NEO address( which is probably the most common mapping)

The second parameter is the hash of the domain name that is to be resolved.

The third parameter is the subdomain name that is to be resolved.

The following code is applied.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{var} \PYG{n+nb}{hash} \PYG{o}{=} \PYG{n}{nameHashArray}\PYG{p}{(}\PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{test}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{cc}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{bb}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{aa}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}\PYG{o}{/}\PYG{o}{/}\PYG{n}{calculate} \PYG{n}{by} \PYG{n}{Client}
\PYG{n}{resolve}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{http}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{n+nb}{hash}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{o}{/}\PYG{o}{/}\PYG{n}{contract} \PYG{n}{resolve} \PYG{n}{http}\PYG{p}{:}\PYG{o}{/}\PYG{o}{/}\PYG{n}{aa}\PYG{o}{.}\PYG{n}{bb}\PYG{o}{.}\PYG{n}{cc}\PYG{o}{.}\PYG{n}{test}
\end{sphinxVerbatim}

or

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
var hash = nameHashArray([\PYGZdq{}test\PYGZdq{},\PYGZdq{}cc\PYGZdq{},\PYGZdq{}bb\PYGZdq{});// calculate by Client
resolve(\PYGZdq{}http\PYGZdq{},hash,“aa\PYGZdq{})//smart resolve http://aa.bb.cc.test
\end{sphinxVerbatim}

The return type is byte{[}{]}, how to interpret byte{[}{]} is defined by different protocols.
byte{[}{]} saves strings. We will write another document to explore protocols.

Second-level domain name has to be resolved in the way of

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{resolve}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{http}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{n+nb}{hash}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{o}{.}
\end{sphinxVerbatim}

Other domain names are recommended to be resolved in the way of

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
resolve(\PYGZdq{}http\PYGZdq{},hash,“aa\PYGZdq{}).
\end{sphinxVerbatim}


\subsubsection{resolveFull(string protocol,string{[}{]} nameArray)}
\label{\detokenize{nns_protocol:resolvefull-string-protocol-string-namearray}}
Complete model of domain name resolution

The first parameter is protocol

The second parameter is NameArray

The only difference in this resolution is it verifies step by step whether the ownership is consistent with the registration.

Its return type is the same with resolve.


\subsection{Owner Interface}
\label{\detokenize{nns_protocol:owner-interface}}
All of the owner interfaces are in the form of

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{owner\PYGZus{}SetXXX}\PYG{p}{(}\PYG{n}{byte}\PYG{p}{[}\PYG{p}{]} \PYG{n}{srcowner}\PYG{p}{,}\PYG{n}{byte}\PYG{p}{[}\PYG{p}{]} \PYG{n}{nnshash}\PYG{p}{,}\PYG{n}{byte}\PYG{p}{[}\PYG{p}{]} \PYG{n}{xxx}\PYG{p}{)}\PYG{o}{.}
\end{sphinxVerbatim}

Xxx is  scripthash.

The return value is one-byte array；{[}0{]} means succeed; {[}1{]} means fail

The owner interface accepts both direct signature of account address calls and smart contract owner calls.
If the owner is a smart contract, the owner should determine their own authority.
If it does not meet the conditions, please do not initiate appcall on the top-level domain contract.


\subsubsection{owner\_SetOwner(byte{[}{]} srcowner,byte{[}{]} nnshash,byte{[}{]} newowner)}
\label{\detokenize{nns_protocol:owner-setowner-byte-srcowner-byte-nnshash-byte-newowner}}
Ownership transfer of domain names. The owner of a domain name could be either an account address or a smart contract.

srcowner is only used to verify signature when the owner is an account address. It is the address’s scripthash.

nnshash is the namehash of the domain name that is to be operated.

newowner is the scripthash of new owners’ address.


\subsubsection{owner\_SetRegister(byte{[}{]} srcowner,byte{[}{]} nnshash,byte{[}{]} newregister)}
\label{\detokenize{nns_protocol:owner-setregister-byte-srcowner-byte-nnshash-byte-newregister}}
Set up Domain Registrar Contract (Domain Registrar is a smart contract) Domain Registrar parameter form must also be 0710, return 05
the following interface must be achieved.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{public} \PYG{n}{static} \PYG{n+nb}{object} \PYG{n}{Main}\PYG{p}{(}\PYG{n}{string} \PYG{n}{method}\PYG{p}{,} \PYG{n+nb}{object}\PYG{p}{[}\PYG{p}{]} \PYG{n}{args}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{k}{if} \PYG{p}{(}\PYG{n}{method} \PYG{o}{==} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{getSubOwner}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
        \PYG{k}{return} \PYG{n}{getSubOwner}\PYG{p}{(}\PYG{p}{(}\PYG{n}{byte}\PYG{p}{[}\PYG{p}{]}\PYG{p}{)}\PYG{n}{args}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{p}{(}\PYG{n}{string}\PYG{p}{)}\PYG{n}{args}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
    \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}

    \PYG{n}{getSubOwner}\PYG{p}{(}\PYG{n}{byte}\PYG{p}{[}\PYG{p}{]} \PYG{n}{nnshash}\PYG{p}{,}\PYG{n}{string} \PYG{n}{subdomain}\PYG{p}{)}
\end{sphinxVerbatim}

Anyone can call the registrar’s interface to check the owner of the subdomain.

There is no regulation for other interface forms of the domain name registrar. The official registrar will be explained in the future documentation.

The domain name registrar achieved by the user only need to achieve getSubOwner interface.


\subsubsection{owner\_SetResolve(byte{[}{]} srcowner,byte{[}{]} nnshash,byte{[}{]} newresolver)}
\label{\detokenize{nns_protocol:owner-setresolve-byte-srcowner-byte-nnshash-byte-newresolver}}
Set up a domain name resolver contract (the domain name resolver is a smart contract)

The domain name resolver’s parameter form also has to be 0710 and return 05

the following interface has to be achieved.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{public} \PYG{n}{static} \PYG{n}{byte}\PYG{p}{[}\PYG{p}{]} \PYG{n}{Main}\PYG{p}{(}\PYG{n}{string} \PYG{n}{method}\PYG{p}{,} \PYG{n+nb}{object}\PYG{p}{[}\PYG{p}{]} \PYG{n}{args}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{k}{if} \PYG{p}{(}\PYG{n}{method} \PYG{o}{==} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{resolve}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
        \PYG{k}{return} \PYG{n}{resolve}\PYG{p}{(}\PYG{p}{(}\PYG{n}{string}\PYG{p}{)}\PYG{n}{args}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{p}{(}\PYG{n}{byte}\PYG{p}{[}\PYG{p}{]}\PYG{p}{)}\PYG{n}{args}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
    \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}

\PYG{n}{resolve}\PYG{p}{(}\PYG{n}{string} \PYG{n}{protocol}\PYG{p}{,}\PYG{n}{byte}\PYG{p}{[}\PYG{p}{]} \PYG{n}{nnshash}\PYG{p}{)}
\end{sphinxVerbatim}

Anyone can call the resolver interface for resolution.

There are no regulations for other interface forms of domain name resolves. The official resolver will be explained in the future documentation.

The domain name registrar achieved by the user only need to achieve resolve interface.


\subsection{Registrar Interface}
\label{\detokenize{nns_protocol:registrar-interface}}
There is only one registrar interface that’s called by registrar smart contract.


\subsubsection{register\_SetSubdomainOwner(byte{[}{]} nnshash,string subdomain,byte{[}{]} newowner,BigInteger ttl)}
\label{\detokenize{nns_protocol:register-setsubdomainowner-byte-nnshash-string-subdomain-byte-newowner-biginteger-ttl}}
register a subdomain name

nnshash is the namehash of the domain names that are to be operated.

subdomain is the subdomain name that is to be operated.

newowner is the scripthash of the new owner’s address.

TTL is the time to live of the domain name( block height)

If succeed, return {[}1{]}, if fail, return {[}0{]}


\section{Detailed Explanation of Owner Contract}
\label{\detokenize{nns_protocol:detailed-explanation-of-owner-contract}}

\subsection{Workings of the Owner Contract}
\label{\detokenize{nns_protocol:workings-of-the-owner-contract}}
The owner contract calls the owner\_SetXXX interface of top-level domain name contract in the form of Appcall.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{[}\PYG{n}{Appcall}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{dffbdd534a41dd4c56ba5ccba9dfaaf4f84e1362}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{]}
\PYG{n}{static} \PYG{n}{extern} \PYG{n+nb}{object} \PYG{n}{rootCall}\PYG{p}{(}\PYG{n}{string} \PYG{n}{method}\PYG{p}{,} \PYG{n+nb}{object}\PYG{p}{[}\PYG{p}{]} \PYG{n}{arr}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

The top-level domain name contract will check the call stack, comparing contract it’s called by and the owner that manages the top-level domain name contract.
So only the owner contract of a domain name can manage this domain name.


\subsection{Significance of the Owner Contract}
\label{\detokenize{nns_protocol:significance-of-the-owner-contract}}
Users could achieve complex contract ownership through the owner contract.

For example:

Owned by two persons, dual signature

Owned by more than two persons, operate by voting


\section{Detailed Explanation of Registrar}
\label{\detokenize{nns_protocol:detailed-explanation-of-registrar}}

\subsection{Workings of Registrar Contract}
\label{\detokenize{nns_protocol:workings-of-registrar-contract}}
The registrar contract calls register\_SetSubdomainOwner interface of the top-level domain name in the form of Appcall.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{[}\PYG{n}{Appcall}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{dffbdd534a41dd4c56ba5ccba9dfaaf4f84e1362}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{]}
\PYG{n}{static} \PYG{n}{extern} \PYG{n+nb}{object} \PYG{n}{rootCall}\PYG{p}{(}\PYG{n}{string} \PYG{n}{method}\PYG{p}{,} \PYG{n+nb}{object}\PYG{p}{[}\PYG{p}{]} \PYG{n}{arr}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

Top-level domain name contracts will check the call stack, comparing the contract it’s called by and the registrar the top-level domain name contract manages.

So only the specified registrar contract can manage it.
the registrar interface

The registrar’s parameter form also has to be 0710 and return 05

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{public} \PYG{n}{static} \PYG{n+nb}{object} \PYG{n}{Main}\PYG{p}{(}\PYG{n}{string} \PYG{n}{method}\PYG{p}{,} \PYG{n+nb}{object}\PYG{p}{[}\PYG{p}{]} \PYG{n}{args}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{k}{if} \PYG{p}{(}\PYG{n}{method} \PYG{o}{==} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{getSubOwner}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
        \PYG{k}{return} \PYG{n}{getSubOwner}\PYG{p}{(}\PYG{p}{(}\PYG{n}{byte}\PYG{p}{[}\PYG{p}{]}\PYG{p}{)}\PYG{n}{args}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{p}{(}\PYG{n}{string}\PYG{p}{)}\PYG{n}{args}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
    \PYG{k}{if} \PYG{p}{(}\PYG{n}{method} \PYG{o}{==} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{requestSubDomain}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
        \PYG{k}{return} \PYG{n}{requestSubDomain}\PYG{p}{(}\PYG{p}{(}\PYG{n}{byte}\PYG{p}{[}\PYG{p}{]}\PYG{p}{)}\PYG{n}{args}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{p}{(}\PYG{n}{byte}\PYG{p}{[}\PYG{p}{]}\PYG{p}{)}\PYG{n}{args}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{p}{(}\PYG{n}{string}\PYG{p}{)}\PYG{n}{args}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
    \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}
\end{sphinxVerbatim}


\subsubsection{getSubOwner(byte{[}{]} nnshash,string subdomain)}
\label{\detokenize{nns_protocol:getsubowner-byte-nnshash-string-subdomain}}
This interface is the norms and requirements of registrars.
It has to be achieved because this interface will be invoked to verify rights when a complete resolution is conducted on the domain name.

nnshash is the hash of the domain name

subdomain is the subdomain name

Return byte{[}{]} owner’s address, or blank


\subsubsection{requestSubDomain(byte{[}{]} who,byte{[}{]} nnshash,string subdomain)}
\label{\detokenize{nns_protocol:requestsubdomain-byte-who-byte-nnshash-string-subdomain}}
This interface will be used by first come first served registrar. Users call the interface of the registrar to register the domain name.

Who means who applies

nnshash means which domain name is applied

subdomain means subdomain name applied


\section{Detailed Explanation of the Resolver}
\label{\detokenize{nns_protocol:detailed-explanation-of-the-resolver}}
The workings of the resolver contract
\begin{enumerate}
\item {} 
The resolver saves resolution information by itself.

\item {} 
The top-level domain name contract calls the resolution interface of the resolver to get resolution information in the way of nep4.

\item {} 
When the resolver sets resolution data, it calls the getInfo interface of the top-level domain name contract to verify the ownership of the domain name in the way of Appcall.

\end{enumerate}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{[}\PYG{n}{Appcall}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{dffbdd534a41dd4c56ba5ccba9dfaaf4f84e1362}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{]}
\PYG{n}{static} \PYG{n}{extern} \PYG{n+nb}{object} \PYG{n}{rootCall}\PYG{p}{(}\PYG{n}{string} \PYG{n}{method}\PYG{p}{,} \PYG{n+nb}{object}\PYG{p}{[}\PYG{p}{]} \PYG{n}{arr}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

Any contract could call the getInfo interface of the top-level domain name contract to verify the ownership of the domain name in the way of Appcall.


\subsection{Resolver Interface}
\label{\detokenize{nns_protocol:resolver-interface}}
The resolver’s parameter form has be 0710, it returns 05.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{public} \PYG{n}{static} \PYG{n}{byte}\PYG{p}{[}\PYG{p}{]} \PYG{n}{Main}\PYG{p}{(}\PYG{n}{string} \PYG{n}{method}\PYG{p}{,} \PYG{n+nb}{object}\PYG{p}{[}\PYG{p}{]} \PYG{n}{args}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{k}{if} \PYG{p}{(}\PYG{n}{method} \PYG{o}{==} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{resolve}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
        \PYG{k}{return} \PYG{n}{resolve}\PYG{p}{(}\PYG{p}{(}\PYG{n}{string}\PYG{p}{)}\PYG{n}{args}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{p}{(}\PYG{n}{byte}\PYG{p}{[}\PYG{p}{]}\PYG{p}{)}\PYG{n}{args}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
    \PYG{k}{if} \PYG{p}{(}\PYG{n}{method} \PYG{o}{==} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{setResolveData}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
        \PYG{k}{return} \PYG{n}{setResolveData}\PYG{p}{(}\PYG{p}{(}\PYG{n}{byte}\PYG{p}{[}\PYG{p}{]}\PYG{p}{)}\PYG{n}{args}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{p}{(}\PYG{n}{byte}\PYG{p}{[}\PYG{p}{]}\PYG{p}{)}\PYG{n}{args}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{p}{(}\PYG{n}{string}\PYG{p}{)}\PYG{n}{args}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{,} \PYG{p}{(}\PYG{n}{string}\PYG{p}{)}\PYG{n}{args}\PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{]}\PYG{p}{,} \PYG{p}{(}\PYG{n}{byte}\PYG{p}{[}\PYG{p}{]}\PYG{p}{)}\PYG{n}{args}\PYG{p}{[}\PYG{l+m+mi}{4}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
    \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}
\end{sphinxVerbatim}


\subsubsection{resolve(string protocol,byte{[}{]} nnshash)}
\label{\detokenize{nns_protocol:resolve-string-protocol-byte-nnshash}}
This interface is the norms and requirements of resolvers. It has to be achieved because this interface will be called for final resolution when a complete resolution is conducted on a domain name.

Protocol  is the string of the protocol

Nnshash  nnshash is the domains name that’s to be resolved.

return byte{[}{]} is to resolve the data


\subsubsection{setResolveData(byte{[}{]} owner,byte{[}{]} nnshash,string or int{[}0{]} subdomain,string protocol,byte{[}{]} data)}
\label{\detokenize{nns_protocol:setresolvedata-byte-owner-byte-nnshash-string-or-int-0-subdomain-string-protocol-byte-data}}
This interface is owned by the standard resolver for demo. The owner(currently it only supports the owner of an account address) could call this interface to configure the resolution data.

owner means the owner of a domain name.

nnshash means set up which domain name

subdomain the set-up subdomain name ( could pass 0; if the set-up is domain name resolution, non-subdomain name passes 0)

protocol means the string of protocols

data means resolves data

Return {[}1{]} means succeed, or {[}0{]} means fail.


\section{NNS Domain Name Registration Mechanism}
\label{\detokenize{nns_protocol:nns-domain-name-registration-mechanism}}
The domain name is a scarce and unique resource.
The core issue that needs to be considered when designing such a system is how to maximize the value of the domain name.
This does not mean that the higher the price of the domain name is speculated, the better it is.

But there should be a reasonable process of value discovery and use.
The first problem faced by the economic model of the domain name system is how to reasonably realize the initial registration and distribution of domain names?


\subsection{Current Domain Name Registration}
\label{\detokenize{nns_protocol:current-domain-name-registration}}
In the registration mechanism of blockchain domain names, there are currently two typical registration methods.
One is first-come, first-served, such as a Bitshares; and the other is ENS’s auction with sealed bidding registration.
Let’s first look at the specific steps as well as advantages and disadvantages of these two methods.

First come, first served is the main method of DNS domain registration.
Service providers usually set different prices for different domain names.
Due to the decentralized nature of blockchain domain names, there will be no complicated pricing in the
first come, first served model. Either free or charge a unified registration fee.
First come, first served method is relatively simple to implement, and the user operation is relatively simple.
However, there is no market pricing process at the time of initial distribution, and there is no multi-participation.
The domain name value needs to be discovered completely in the secondary market.

When there are few use cases for blockchain domain names, its value is not high and it is not used a lot,
first come, first served method can be used as a convenient implementation, but when the demand for blockchain domain names increases,
the first-come-first-served does not reflect the market demand well and does not maximize the value of domain names.

Ethereum’s domain name service ENS adopts a sealed auction registration method.
Its registration process is composed of bid opening, placing, revealing, and bid winning?.
The whole process lasts about 7 days, and the main part is placing a bid and revealing a bid process.
The blockchain is an open and transparent ledger system. In order to achieve sealed bidding, the user’s bid consists of two parts,
one is the real bid, and the other is the confusion money.
Others can see your total bid in the system rather than your real bid to avoid the information advantage of later bidding.
In the bid revealing stage, the user needs to send his own locally saved ciphertext to the smart contract to reveal the true bid.
After the revealing period is over, the final bid winner will be determined.

The disadvantage of auctions with sealed bidding is that they cannot achieve a complete seal,
and there will still be information leaks because the actual bid cannot exceed the total price.
Second, the user experience is poor. The user needs to save the ciphertext and reveal the bid in the bid revealing period on time.
Users need to do a lot of work, or it will lose the qualification and bid fund.

We believe that sealed bids are not completely sealed, and the auction experience is poor, so NNS hopes to find a better auction mechanism.


\subsection{Transparent Bidding Mechanism}
\label{\detokenize{nns_protocol:transparent-bidding-mechanism}}
NNS will still use the bidding method to achieve the initial registration and distribution of domain names.
However, unlike ENS, we adopt a transparent bidding mechanism.
The advantage of this is that the user does not need to remember the ciphertext and there will be no bid revealing period.
As long as the bidding is over, the final result can be known at once.
However, there will be a problem with the transparent bidding.
If the bidding period is certain, no one is willing to bid for the domain name at the beginning,
because others can get a little more money to outbid you at the end of the auction.
In order to solve the problem of the early bidding disadvantage, we introduce \sphinxcode{\sphinxupquote{randomness}} at the end time of the auction.
The auction is composed of two phases.

\sphinxstylestrong{Fixed Period}

The first phase is a fixed period, for example, 3 days.
All bids during this period are valid.

\sphinxstylestrong{Random Period}

If someone bids on the last day of the fixed period,
then here comes an additional two-day random period, otherwise the auction ends on the third day of the fixed period.
During the random period, the end time of the auction is uncertain.

It is necessary to wait until the hash value of the futures blocks of two additional days is determined.
According to the size of the interval, the latter someone bids,
the more likely he or she is to fall out of the end time of the auction and thus the bidding will be invalid,
so it’s better to bid as early as possible.

\sphinxstylestrong{Ends of auction}

After a random period is finished,
the bid ending block will be determined according to the hash of future blocks.
The bid winner can be determined after all the bids from the bid opening and the ending block are collected.

\noindent{\hspace*{\fill}\scalebox{1.000000}{\sphinxincludegraphics[width=800\sphinxpxdimen,height=700\sphinxpxdimen]{{bidding}.jpeg}}\hspace*{\fill}}

The end result of this auction method is that if you think that nobody bids against you for a domain name,
then you only need to bid within two days after opening the bid,
then you can win a domain name after the fixed period is finished on the third day.

If there is competition for a domain name, then the competition mainly occurs
at both ends of the alternating period of the fixed period and the random period.
By introducing a random end time of the auction, the late bidding is the less likely to fall within the valid period,
avoiding the problem of the late bidding advantage caused by increasing transparency in the auction.


\subsection{Rent mechanism}
\label{\detokenize{nns_protocol:rent-mechanism}}
The registration mechanism only achieves the value discovery at the time of initial distribution.
If the domain name is acquired by someone but never used, it is a waste of value.
Later, we will analyze how to use the rent mechanism to promote the circulation in the secondary domain name market.


\section{Technical Realization of Lock-free Cyclical Redistributed Token NNC}
\label{\detokenize{nns_protocol:technical-realization-of-lock-free-cyclical-redistributed-token-nnc}}
The NNS’s economic system needs an asset, so we designed an asset.

The NNS’s economic system requires that the total assets remain unchanged, and the auction proceeds and rental costs are considered as destroyed,
so the assets we design can be consumed and the consumed assets will be redistributed, since destruction and redistribution will be cyclical,
so we call it cyclically redistributed token. Lock-free refers to the redistribution process will not lock the users’ assets.
The details of this will be explained below.


\subsection{Initial Distribution of Tokens}
\label{\detokenize{nns_protocol:initial-distribution-of-tokens}}
NNC will be initially distributed through an ICO mechanism.


\subsection{Redistribution Mechanism}
\label{\detokenize{nns_protocol:redistribution-mechanism}}
We use the destruction interface to destroy tokens. Tokens to be destroyed are:
\begin{enumerate}
\item {} 
Rent cost will be destroyed by the system

\item {} 
Revenue from second-level domain name auction will be destroyed by the system.

\item {} 
If anyone wants to destroy part of his or her tokens, they will be destroyed by the system.

\end{enumerate}

Once token is destroyed, they are counted into destruction pool. Assets in the destruction pool will go into the bonus pool, from which users could collect assets.


\subsection{Lock-free Bonus Collection}
\label{\detokenize{nns_protocol:lock-free-bonus-collection}}
Like an auction, this kind of system is usually composed of four stages: opening a bid, placing a bid, revealing a bid and winning a bid.
Users’ tokens have to be paid into the system during the bidding, which means users’ assets are locked,
consumed after winning the bid or unlocked if the bid is missed.

However, NNC token is not composed of stages including participating bonus collection, waiting for the bonus and collecting the bonus,
which means users’ assets are not locked in the whole process.

NNC uses the mechanism of the bonus pool queue, as shown in the above picture, only a fixed number of bonus pools (for example, five) are kept.
The oldest bonus pool(the head pool)will be destroyed when more than five bonus pools are generated.

Besides the bonus pool, users’ assets are composed of two types: fixed assets and change. The holding time of fixed assets can only increase, and users whose holding time is earlier than collection time of a bonus pool are qualified to collect the bonus.

The holding time of fixed assets increases after collecting the bonus. It’s like coin hours is consumed, thus preventing the repeated collection of the same bonus.


\subsection{Details of The Bonus Pool}
\label{\detokenize{nns_protocol:details-of-the-bonus-pool}}
The token will maintain several bonus pools. When each bonus pool is generated, the assets in the destruction pool will all be transferred into this bonus pool.
If the maximum bonus pool number is exceeded, the oldest bonus pool will also be destroyed and the remaining assets in the destroyed bonus pool will also be counted in the latest bonus pool.

The number of bonus pools is fixed, for example, a bonus pool is generated for every 4096 blocks.
A maximum of five bonus pools are maintained. When the sixth bonus pool is generated, the first bonus pool will be destroyed,
and all of its assets are placed in the latest bonus pool. The above number of bonus pools and how often one bonus pool is produced are both tentative).
Each bonus pool will correspond to a block, this block is the bonus collection time, only those whose holding time is earlier than
the bonus collection time can collect the bonus.


\subsection{Details of Fixed Assets and Exchange}
\label{\detokenize{nns_protocol:details-of-fixed-assets-and-exchange}}
Fixed assets and change, of which fixed assets record a holding time.

Fixed assets and change only affect the amount of the award, the rest of the functions are not affected.

Fixed assets + change = user’s balance of assets

Fixed assets do not have a fractional part, the decimal part is counted in the change. When “ considered as fixed assets” is mentioned below, it means the integer part is considered as fixed assets, and decimal part as change.

Change will be firstly used in the transfer of tokens and fixed assets will be used only when the change is not enough.

Transferrer: fixed assets can only be reduced.

Transferee: fixed assets remain unchanged, the transferred value is counted in the change.

Fixed assets can only be increased in two ways:
\begin{enumerate}
\item {} 
\sphinxstylestrong{Create an account}.

\end{enumerate}
\begin{quote}

(a transfer to an address which has no NNC is regarded as creating an account)
The transferred assets are regarded as fixed assets and the holding time is the new block ID.
\end{quote}
\begin{enumerate}
\setcounter{enumi}{1}
\item {} 
\sphinxstylestrong{Collect the bonus}.

\end{enumerate}
\begin{quote}

After collecting the bonus, personal assets and the collected bonus will be considered as fixed assets, holding time is the bonus block.
\end{quote}

When collecting the bonus, users can only collect bonus when their holding time is earlier than bonus pool time.
Bonus collection ratio is calculated as the total amount in the current bonus pools/(the total issuance volume-the total amount in the current bonus pools)

Let’s take numbers to exemplify it. For example, there are 3 bonus pools: they were produced by block 4096，8000，10000. One user’s fixed assets is 100. His holding time is 7000, then he cannot collect the bonus in the first pool, but can collect the bonus from the second and third pools. The current block is 10500. Once the user collects the bonus, his assets holding time becomes 10500, so he cannot collect the bonus from any pools.

For example, there is 50300000 NNC in a bonus pool. Then the user’s bonus collection ratio is

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
50300000 /（100000000\PYGZhy{}50300000）=1.23587223
\end{sphinxVerbatim}

This user’s fixed asset is 100, then he can collect 123.587223 NNC from the pool.
If there is 500, 000 NNC in a bonus pool, then his collection ratio is

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
500000 /（100000000\PYGZhy{}500000）=0.00502512
\end{sphinxVerbatim}

as the user has 100 NNC of fixed asset, then he can collect 0.502512 NNC from the pool.


\subsection{NNC Interface(only additional interfaces compared with NEP 5 will be described)}
\label{\detokenize{nns_protocol:nnc-interface-only-additional-interfaces-compared-with-nep-5-will-be-described}}
NNC first meets the NEP5 standard, and the NEP standard interface will not be described any more.


\subsubsection{balanceOfDetail(byte{[}{]} address)}
\label{\detokenize{nns_protocol:balanceofdetail-byte-address}}
Returning the details of the user’s assets, such as how much fixed assets, how much change, the total amount.
Fixed assets holding block does not need a signature. Anybody can check it.

Return structure:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{\PYGZob{}}
    \PYG{n}{Cash} \PYG{n}{amount}
    \PYG{n}{The} \PYG{n}{amount} \PYG{n}{of} \PYG{n}{fixed} \PYG{n}{assets}
    \PYG{n}{Fixed} \PYG{n}{assets} \PYG{n}{generation} \PYG{n}{time}\PYG{p}{(} \PYG{n}{new} \PYG{n}{block} \PYG{n}{ID}\PYG{p}{)}
    \PYG{n}{Balance} \PYG{p}{(}\PYG{n}{fixed} \PYG{n}{assets} \PYG{o}{+} \PYG{n}{cash}\PYG{p}{)}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}


\subsubsection{use(byte{[}{]} address,BigInteger value)}
\label{\detokenize{nns_protocol:use-byte-address-biginteger-value}}
The consumption of assets in an account requires the account signature.

Consumed assets go into bonus pools.


\subsubsection{getBonus(byte{[}{]} address)}
\label{\detokenize{nns_protocol:getbonus-byte-address}}
Account signature is required when designated accounts collect the bonus.

After the collection of the bonus, the total assets in this account will be considered as fixed assets and fixed assets holding block
of this account will be changed.


\subsubsection{checkBonus()}
\label{\detokenize{nns_protocol:checkbonus}}
Checking current bonus pool doesn’t need a signature.

\sphinxstyleemphasis{Return} \sphinxtitleref{Array\textless{}BonusInfo\textgreater{}}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{BonusInfo}
\PYG{p}{\PYGZob{}}
    \PYG{n}{StartBlock}\PYG{p}{;}\PYG{o}{/}\PYG{o}{/}\PYG{n}{bonus} \PYG{n}{collecting} \PYG{n}{block}
    \PYG{n}{BonusCount}\PYG{p}{;}\PYG{o}{/}\PYG{o}{/}\PYG{n}{total} \PYG{n}{amount} \PYG{n}{of} \PYG{n}{this} \PYG{n}{bonus} \PYG{n}{pool}
    \PYG{n}{BonusValue}\PYG{p}{;}\PYG{o}{/}\PYG{o}{/} \PYG{n}{remaining} \PYG{n}{amount} \PYG{n}{of} \PYG{n}{this} \PYG{n}{bonus} \PYG{n}{pool}\PYG{o}{.}
    \PYG{n}{LastIndex}\PYG{p}{;}\PYG{o}{/}\PYG{o}{/} \PYG{n}{the} \PYG{n+nb}{id} \PYG{n}{of} \PYG{n}{last} \PYG{n}{bonus}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}


\subsubsection{newBonus ()}
\label{\detokenize{nns_protocol:newbonus}}
Generating a new bonus pool can be called by anyone. But the bonus pool generation has to meet the bonus pool interval, so repeated calls is useless.
This interface can be seen as a push to generate a new bonus pool.


\chapter{Summary}
\label{\detokenize{nns_summary:summary}}\label{\detokenize{nns_summary::doc}}
The NNS project is a smart contract protocol layer application built entirely on the NEO blockchain and is a true blockchain application.
The combination of many projects and blockchain is just to issue a kind of token, the service of the token is provided by a central organization,
while all services of the NNS are provided by the smart contract, which is distributed and flexible and extensible, without centralization risks.

NNS is a large-scale application of NEO smart contract system. In order to achieve resolver flexibility and scalability, we apply the latest NEP4 dynamic call.
In the economic model, we will design the Vickrey auction contract and the Dutch auction contract. In order to achieve an easy redistribution of system costs,
we’ve extended the NEP5 tokens standard and added the concept of coin days to allow system revenue redistribution without locking tokens,
blending application tokens and equity into one kind of token.

As domain name services can improve the usability of the blockchain and have rich usage scenarios, there will form an ecosystem around domain names.
In the future, we will work with NEO Eco-system C-lients to allow all NEO wallets to support the transfer of tokens via alias.
We will also explore new usage scenarios such as working with pet games and giving pets nicknames via NNS.
In the future, as the NEO ecosystem is used more and more, the domain name of NNS will become more and more valuable.


\chapter{Developers}
\label{\detokenize{nns_developer::doc}}\label{\detokenize{nns_developer:developers}}
\sphinxstylestrong{Liu Yongxin（Jason Liu）}

Founder
Co-founder of NEL( a Chinese NEO developer community)

\sphinxstylestrong{Li Jianying}

CTO Co-founder \& CTO
NEO core developer, co-initiator of NEL(a Chinese NEO developer community)

\sphinxstylestrong{Liu Qianming}

Core developer, full-stack engineer

\sphinxstylestrong{Zhao Ben}

Web developer

\sphinxstylestrong{Wang Xiangjian (Robbie Wang)}

Overseas communities operation manager


\chapter{Indices and tables}
\label{\detokenize{index:indices-and-tables}}\begin{itemize}
\item {} 
\DUrole{xref,std,std-ref}{genindex}

\item {} 
\DUrole{xref,std,std-ref}{modindex}

\item {} 
\DUrole{xref,std,std-ref}{search}

\end{itemize}



\renewcommand{\indexname}{Index}
\printindex
\end{document}